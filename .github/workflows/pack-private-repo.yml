name: Auto Pack Private Repo On Push

on:
  repository_dispatch:
    types: [pack_trigger]
  workflow_dispatch:

permissions:
  contents: write
  actions: read

jobs:
  pack-specific-repo:
    runs-on: windows-latest

    steps:
      # -----------------------------
      # Step 1ï¼šé…ç½® Git å‡­è¯ï¼ˆæ‹‰ç§æœ‰ä»“åº“ï¼‰
      # -----------------------------
      - name: Configure Git Credentials
        shell: bash
        run: |
          git config --global credential.helper store
          echo "https://${{ secrets.PRIVATE_REPO_TOKEN }}:@github.com" > ~/.git-credentials

      # -----------------------------
      # Step 2ï¼šå…‹éš†ç›®æ ‡ä»“åº“
      # -----------------------------
      - name: Clone Triggered Private Repository
        shell: bash
        env:
          REPO_NAME: ${{ github.event.client_payload.repo_name }}
          REPO_BRANCH: ${{ github.event.client_payload.repo_branch }}
          GITHUB_USER: ${{ github.event.client_payload.github_user }}
        run: |
          set -e

          if [ -z "$REPO_NAME" ] || [ -z "$GITHUB_USER" ]; then
            echo "âŒ ç¼ºå°‘ repo_name / github_user"
            exit 1
          fi

          REPO_URL="https://github.com/$GITHUB_USER/$REPO_NAME.git"
          git clone "$REPO_URL" target-repo
          cd target-repo

          git checkout ${REPO_BRANCH:-main}

      # -----------------------------
      # Step 3ï¼šå®‰è£…ä¾èµ–ï¼ˆè‡ªåŠ¨è¯†åˆ«ï¼‰
      # -----------------------------
      - name: Install Dependencies
        working-directory: ./target-repo
        shell: bash
        run: |
          set -e

          if [ -f "package.json" ]; then
            npm install
          elif [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
          elif [ -f "pom.xml" ]; then
            echo "Maven é¡¹ç›®ï¼Œè·³è¿‡ä¾èµ–å®‰è£…"
          elif ls *.csproj 1> /dev/null 2>&1 || ls *.sln 1> /dev/null 2>&1; then
            echo ".NET é¡¹ç›®ï¼Œä½¿ç”¨ dotnet restore"
            dotnet restore
          fi

      # -----------------------------
      # Step 4ï¼šæ„å»ºé¡¹ç›®
      # -----------------------------
      - name: Build Project
        working-directory: ./target-repo
        shell: bash
        run: |
          set -e

          if [ -f "package.json" ]; then
            npm run build
          elif [ -f "pom.xml" ]; then
            mvn package -DskipTests
          elif [ -f "requirements.txt" ] && [ -f "main.py" ]; then
            pyinstaller --onefile main.py
          elif ls *.csproj 1> /dev/null 2>&1 || ls *.sln 1> /dev/null 2>&1; then
            echo "ğŸš€ æ„å»º .NET é¡¹ç›®"
            dotnet publish -c Release -r win-x64 --self-contained true \
              -p:PublishSingleFile=true \
              -o publish/
          else
            echo "âš  æœªè¯†åˆ«æ„å»ºç±»å‹ï¼Œè·³è¿‡"
          fi

      # -----------------------------
      # Step 5ï¼šæ”¶é›†æ„å»ºäº§ç‰©
      # -----------------------------
      - name: Collect Build Artifacts
        id: collect
        shell: bash
        run: |
          set -e

          OUT="$GITHUB_WORKSPACE/build-artifacts"
          mkdir -p "$OUT"

          for dir in publish dist target build out bin release; do
            if [ -d "./target-repo/$dir" ]; then
              cp -r "./target-repo/$dir"/* "$OUT/" || true
            fi
          done

          find ./target-repo -maxdepth 1 -type f \
            \( -name "*.exe" -o -name "*.zip" -o -name "*.jar" -o -name "*.apk" -o -name "*.dmg" \) \
            -exec cp {} "$OUT/" \;

          if [ "$(ls -A "$OUT")" ]; then
            echo "has_artifacts=true" >> $GITHUB_OUTPUT
          else
            echo "has_artifacts=false" >> $GITHUB_OUTPUT
          fi

      - name: Ensure Artifacts Exist
        if: steps.collect.outputs.has_artifacts != 'true'
        run: |
          echo "::error::æœªæ‰¾åˆ°ä»»ä½•æ„å»ºäº§ç‰©"
          exit 1

      # -----------------------------
      # Step 6ï¼šRelease èµ„äº§å»é‡ï¼ˆæ ¸å¿ƒä¿®å¤ç‚¹ï¼‰
      # -----------------------------
      - name: Deduplicate Release Assets
        shell: pwsh
        run: |
          $src = "build-artifacts"
          $dst = "release-assets"

          New-Item $dst -ItemType Directory -Force | Out-Null
          $map = @{}

          Get-ChildItem $src -Recurse -File | Where-Object {
            $_.Extension -ne ".pdb"
          } | ForEach-Object {
            if (-not $map.ContainsKey($_.Name)) {
              $map[$_.Name] = $_
            }
          }

          foreach ($file in $map.Values) {
            Copy-Item $file.FullName $dst
          }

          Write-Host "æœ€ç»ˆä¸Šä¼ æ–‡ä»¶åˆ—è¡¨ï¼š"
          Get-ChildItem $dst

      # -----------------------------
      # Step 7ï¼šç”Ÿæˆ Tag
      # -----------------------------
      - name: Generate Release Tag
        id: tag
        shell: bash
        run: |
          TS=$(date +'%Y%m%d-%H%M%S')-${GITHUB_RUN_NUMBER}
          NAME="${{ github.event.client_payload.repo_name }}"
          [ -z "$NAME" ] && NAME="manual-build"
          echo "tag_name=${NAME}-${TS}" >> $GITHUB_OUTPUT

      # -----------------------------
      # Step 8ï¼šåˆ›å»º Releaseï¼ˆä¸ä¼šå† 404ï¼‰
      # -----------------------------
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag_name }}
          name: Release ${{ steps.tag.outputs.tag_name }}
          body: |
            Source Repo: ${{ github.event.client_payload.github_user }}/${{ github.event.client_payload.repo_name }}
            Branch: ${{ github.event.client_payload.repo_branch }}
          files: release-assets/*
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
