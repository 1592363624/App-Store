name: Auto Pack Private Repo On Push

on:
  repository_dispatch:
    types: [pack_trigger]
  workflow_dispatch:

permissions:
  contents: write
  actions: read
  statuses: write

jobs:
  pack-specific-repo:
    runs-on: windows-latest

    steps:
      # -----------------------------
      # Step 0: Checkout App-Store (æœ¬ä»“åº“)
      # -----------------------------
      - name: Checkout App-Store
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      # -----------------------------
      # Step 0.5: è®¾ç½® Commit çŠ¶æ€ä¸º Pendingï¼ˆä¸ºäº†åœ¨ GitHub UI æ˜¾ç¤ºè¿è¡Œä¸­ï¼‰
      # -----------------------------
      - name: Set Commit Status Pending
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: 'pending',
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              description: 'Pack Private Repo is running...',
              context: 'Pack Private Repo'
            })

      # -----------------------------
      # Step 1ï¼šé…ç½® Git å‡­è¯ï¼ˆæ‹‰ç§æœ‰ä»“åº“ï¼‰
      # -----------------------------
      - name: Configure Git Credentials
        shell: bash
        run: |
          git config --global credential.helper store
          echo "https://${{ secrets.PRIVATE_REPO_TOKEN }}:@github.com" > ~/.git-credentials

      # -----------------------------
      # Step 2ï¼šå…‹éš†ç›®æ ‡ä»“åº“
      # -----------------------------
      - name: Clone Triggered Private Repository
        shell: bash
        env:
          REPO_NAME: ${{ github.event.client_payload.repo_name }}
          REPO_BRANCH: ${{ github.event.client_payload.repo_branch }}
          GITHUB_USER: ${{ github.event.client_payload.github_user }}
        run: |
          set -e

          if [ -z "$REPO_NAME" ] || [ -z "$GITHUB_USER" ]; then
            echo "âŒ ç¼ºå°‘ repo_name / github_user"
            exit 1
          fi

          REPO_URL="https://github.com/$GITHUB_USER/$REPO_NAME.git"
          git clone "$REPO_URL" target-repo
          cd target-repo

          git checkout ${REPO_BRANCH:-main}
          
          # è·å–æœ€è¿‘ä¸€æ¬¡æäº¤ä¿¡æ¯ (ç”¨äºæ›´æ–° README)
          LAST_MSG=$(git log -1 --pretty=%s)
          echo "COMMIT_MSG<<EOF" >> $GITHUB_ENV
          echo "$LAST_MSG" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      # -----------------------------
      # Step 3ï¼šå®‰è£…ä¾èµ–ï¼ˆè‡ªåŠ¨è¯†åˆ«ï¼‰
      # -----------------------------
      - name: Install Dependencies
        working-directory: ./target-repo
        shell: bash
        run: |
          set -e

          if [ -f "package.json" ]; then
            npm install
          elif [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
          elif [ -f "pom.xml" ]; then
            echo "Maven é¡¹ç›®ï¼Œè·³è¿‡ä¾èµ–å®‰è£…"
          elif ls *.csproj 1> /dev/null 2>&1 || ls *.sln 1> /dev/null 2>&1; then
            echo ".NET é¡¹ç›®ï¼Œä½¿ç”¨ dotnet restore"
            dotnet restore
          fi

      # -----------------------------
      # Step 4ï¼šæ„å»ºé¡¹ç›®
      # -----------------------------
      - name: Build Project
        working-directory: ./target-repo
        shell: bash
        run: |
          set -e

          # ğŸ§¹ Clean potential stale artifacts before build
          rm -rf publish dist target build out bin release

          if [ -f "package.json" ]; then
            npm install # Re-ensure install if needed, but Step 3 did it.
            npm run build
            # Attempt to detect output directory
            if [ -d "dist" ]; then echo "BUILD_OUTPUT_DIR=dist" >> $GITHUB_ENV; fi
            if [ -d "build" ]; then echo "BUILD_OUTPUT_DIR=build" >> $GITHUB_ENV; fi
          elif [ -f "pom.xml" ]; then
            mvn package -DskipTests
            echo "BUILD_OUTPUT_DIR=target" >> $GITHUB_ENV
          elif [ -f "requirements.txt" ] && [ -f "main.py" ]; then
            pyinstaller --onefile main.py
            echo "BUILD_OUTPUT_DIR=dist" >> $GITHUB_ENV
          elif ls *.csproj 1> /dev/null 2>&1 || ls *.sln 1> /dev/null 2>&1; then
            echo "ğŸš€ å‘ç° .NET é¡¹ç›®ï¼Œå¼€å§‹é€ä¸ªæ„å»º..."
            
            # åˆ›å»ºä¸´æ—¶ç›®å½•å­˜æ”¾åŸå§‹å‘å¸ƒæ–‡ä»¶
            mkdir -p publish_raw
            mkdir -p publish_output

            # éå†æ‰€æœ‰ .csproj æ–‡ä»¶ (æ’é™¤ Tests æµ‹è¯•é¡¹ç›®)
            find . -name "*.csproj" | grep -v "Test" | while read proj; do
              PROJ_NAME=$(basename "$proj" .csproj)
              echo "ğŸ‘‰ æ­£åœ¨æ„å»ºé¡¹ç›®: $PROJ_NAME"
              
              # å‘å¸ƒåˆ°ç‹¬ç«‹ç›®å½•ï¼Œé˜²æ­¢æ··æ·†
              dotnet publish "$proj" -c Release -r win-x64 --self-contained true \
                -p:PublishSingleFile=true \
                -o "publish_raw/$PROJ_NAME"

              # æ‰“åŒ…æˆç‹¬ç«‹ Zip
              echo "ğŸ“¦ æ­£åœ¨æ‰“åŒ…: $PROJ_NAME.zip"
              if command -v 7z > /dev/null; then
                7z a -tzip "publish_output/$PROJ_NAME.zip" "./publish_raw/$PROJ_NAME/*"
              else
                # Fallback to PowerShell for zipping if 7z is missing
                powershell -Command "Compress-Archive -Path 'publish_raw/$PROJ_NAME/*' -DestinationPath 'publish_output/$PROJ_NAME.zip'"
              fi
            done
            
            echo "BUILD_OUTPUT_DIR=publish_output" >> $GITHUB_ENV
          else
            echo "âš  æœªè¯†åˆ«æ„å»ºç±»å‹ï¼Œè·³è¿‡"
          fi

      # -----------------------------
      # Step 5ï¼šæ”¶é›†æ„å»ºäº§ç‰©
      # -----------------------------
      - name: Collect Build Artifacts
        id: collect
        shell: bash
        run: |
          set -e

          OUT="$GITHUB_WORKSPACE/build-artifacts"
          mkdir -p "$OUT"

          if [ -n "$BUILD_OUTPUT_DIR" ]; then
            echo "âœ… ä½¿ç”¨æ˜ç¡®çš„æ„å»ºè¾“å‡ºç›®å½•: $BUILD_OUTPUT_DIR"
            if [ -d "./target-repo/$BUILD_OUTPUT_DIR" ]; then
              cp -r "./target-repo/$BUILD_OUTPUT_DIR"/* "$OUT/" || true
            fi
          else
            echo "âš  æœªæ£€æµ‹åˆ°æ˜ç¡®è¾“å‡ºç›®å½•ï¼Œå°è¯•è‡ªåŠ¨æ‰«æ..."
            # Removed 'bin' to avoid intermediate files
            for dir in publish dist target build out release; do
              if [ -d "./target-repo/$dir" ]; then
                cp -r "./target-repo/$dir"/* "$OUT/" || true
              fi
            done

            find ./target-repo -maxdepth 1 -type f \
              \( -name "*.exe" -o -name "*.zip" -o -name "*.jar" -o -name "*.apk" -o -name "*.dmg" \) \
              -exec cp {} "$OUT/" \;
          fi

          if [ "$(ls -A "$OUT")" ]; then
            echo "has_artifacts=true" >> $GITHUB_OUTPUT
          else
            echo "has_artifacts=false" >> $GITHUB_OUTPUT
          fi

      - name: Ensure Artifacts Exist
        if: steps.collect.outputs.has_artifacts != 'true'
        run: |
          echo "::error::æœªæ‰¾åˆ°ä»»ä½•æ„å»ºäº§ç‰©"
          exit 1

      # -----------------------------
      # Step 6ï¼šRelease èµ„äº§å»é‡ï¼ˆæ ¸å¿ƒä¿®å¤ç‚¹ï¼‰
      # -----------------------------
      - name: Deduplicate Release Assets
        shell: pwsh
        run: |
          $src = "build-artifacts"
          $dst = "release-assets"

          New-Item $dst -ItemType Directory -Force | Out-Null
          $map = @{}

          Get-ChildItem $src -Recurse -File | Where-Object {
            $_.Extension -ne ".pdb"
          } | ForEach-Object {
            if (-not $map.ContainsKey($_.Name)) {
              $map[$_.Name] = $_
            }
          }

          foreach ($file in $map.Values) {
            Copy-Item $file.FullName $dst
          }

          Write-Host "æœ€ç»ˆä¸Šä¼ æ–‡ä»¶åˆ—è¡¨ï¼š"
          Get-ChildItem $dst

      # -----------------------------
      # Step 7ï¼šç”Ÿæˆ Tag
      # -----------------------------
      - name: Generate Release Tag
        id: tag
        shell: bash
        run: |
          # ä¿®æ­£æ—¶åŒºï¼šGitHub Actions é»˜è®¤ä¸º UTCï¼Œè¿™é‡Œæ‰‹åŠ¨è°ƒæ•´ä¸º UTC+8 (åŒ—äº¬æ—¶é—´)
          TS=$(TZ='Asia/Shanghai' date +'%Y%m%d-%H%M%S')-${GITHUB_RUN_NUMBER}
          NAME="${{ github.event.client_payload.repo_name }}"
          [ -z "$NAME" ] && NAME="manual-build"
          echo "tag_name=${NAME}-${TS}" >> $GITHUB_OUTPUT

      # -----------------------------
      # Step 8ï¼šåˆ›å»º Releaseï¼ˆä¸ä¼šå† 404ï¼‰
      # -----------------------------
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag_name }}
          name: Release ${{ steps.tag.outputs.tag_name }}
          body: |
            Source Repo: ${{ github.event.client_payload.github_user }}/${{ github.event.client_payload.repo_name }}
            Branch: ${{ github.event.client_payload.repo_branch }}
          files: release-assets/*
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # -----------------------------
      # Step 10: æ›´æ–° README.md (è‡ªåŠ¨ç”Ÿæˆä¸‹è½½åˆ—è¡¨)
      # -----------------------------
      - name: Update README with Latest Release
        if: success()
        shell: python
        env:
          TAG_NAME: ${{ steps.tag.outputs.tag_name }}
          REPO_NAME: ${{ github.event.client_payload.repo_name }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          import os
          import re
          import datetime

          # é…ç½®
          readme_path = "README.md"
          marker_start = "<!-- RELEASE_TABLE_START -->"
          marker_end = "<!-- RELEASE_TABLE_END -->"
          header = "| é¡¹ç›® (Project) | ç‰ˆæœ¬ (Tag) | æ›´æ–°æ—¶é—´ (Time) | æ›´æ–°æ—¥å¿— (Log) | ä¸‹è½½ (Download) |\n| :--- | :--- | :--- | :--- | :--- |"
          
          # è·å–è¾“å…¥
          tag_name = os.environ.get("TAG_NAME", "Unknown")
          repo_name = os.environ.get("REPO_NAME", "Unknown")
          commit_msg = os.environ.get("COMMIT_MSG", "Update")
          current_repo = os.environ.get("GITHUB_REPOSITORY")
          
          # åŒ—äº¬æ—¶é—´
          utc_now = datetime.datetime.utcnow()
          beijing_now = utc_now + datetime.timedelta(hours=8)
          time_str = beijing_now.strftime("%Y-%m-%d %H:%M")

          # æ‰«æäº§ç‰©
          assets_dir = "release-assets"
          new_rows = {}
          
          if os.path.exists(assets_dir):
              for f in os.listdir(assets_dir):
                  if not f.endswith(".zip"): continue
                  
                  # é¡¹ç›®å (å»åç¼€)
                  proj_name = f[:-4]
                  download_url = f"https://github.com/{current_repo}/releases/download/{tag_name}/{f}"
                  
                  # æ¸…ç†æ—¥å¿—ä¸­çš„ç‰¹æ®Šå­—ç¬¦
                  safe_msg = commit_msg.split('\n')[0].replace('|', '\|').strip()
                  
                  # æ„é€ è¡Œ
                  row = f"| {proj_name} | {tag_name} | {time_str} | {safe_msg} | [ç‚¹å‡»ä¸‹è½½]({download_url}) |"
                  new_rows[proj_name] = row

          if not new_rows:
              print("No zip assets found, skipping README update.")
              exit(0)

          # è¯»å– README
          if not os.path.exists(readme_path):
              content = f"# App Store\n\n## ğŸ“¦ æœ€æ–°å‘å¸ƒ (Latest Releases)\n{marker_start}\n{marker_end}\n"
          else:
              with open(readme_path, "r", encoding="utf-8") as f:
                  content = f.read()
              
              # ç¡®ä¿æœ‰ Marker
              if marker_start not in content:
                  content += f"\n\n## ğŸ“¦ æœ€æ–°å‘å¸ƒ (Latest Releases)\n{marker_start}\n{marker_end}\n"

          # æå–å¹¶è§£ææ—§è¡¨æ ¼ï¼ˆä¿ç•™å…¶ä»–é¡¹ç›®çš„è®°å½•ï¼‰
          pattern = re.compile(f"{re.escape(marker_start)}(.*?){re.escape(marker_end)}", re.DOTALL)
          match = pattern.search(content)
          
          final_rows = {}
          
          if match:
              old_table_block = match.group(1).strip()
              lines = old_table_block.split('\n')
              for line in lines:
                  if not line.strip().startswith("|") or "---" in line or "Project" in line:
                      continue
                  
                  parts = [p.strip() for p in line.split('|')]
                  if len(parts) >= 2:
                      p_name = parts[1]
                      if p_name:
                          final_rows[p_name] = line

          # æ›´æ–°å½“å‰é¡¹ç›®çš„è¡Œ
          for name, row in new_rows.items():
              final_rows[name] = row
              print(f"Updated entry for: {name}")

          # é‡æ–°ç”Ÿæˆè¡¨æ ¼
          sorted_rows = [final_rows[k] for k in sorted(final_rows.keys())]
          new_table = f"\n{header}\n" + "\n".join(sorted_rows) + "\n"
          
          # æ›¿æ¢å†…å®¹
          new_content = pattern.sub(f"{marker_start}{new_table}{marker_end}", content)
          
          with open(readme_path, "w", encoding="utf-8") as f:
              f.write(new_content)

      # -----------------------------
      # Step 11: æäº¤ README å˜æ›´
      # -----------------------------
      - name: Commit and Push README
        if: success()
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md
          git commit -m "docs: auto update readme for release ${{ steps.tag.outputs.tag_name }}" || echo "No changes to commit"
          git push origin main

      # -----------------------------
      # Step 12: æ›´æ–° Commit çŠ¶æ€ï¼ˆæˆåŠŸæˆ–å¤±è´¥ï¼‰
      # -----------------------------
      - name: Update Commit Status
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const state = '${{ job.status }}' === 'success' ? 'success' : 'failure';
            const description = '${{ job.status }}' === 'success' ? 'Build succeeded' : 'Build failed';
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: state,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              description: description,
              context: 'Pack Private Repo'
            });
